{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Карта</title>
  <link rel="icon" href="{% static 'images/fire.png' %}" type="image/icon type">
  <script src="{% static 'jquery/jquery-3.2.1.min.js' %}"></script>
  <script src="{% static 'javascript/assets/particles.min.js' %}"></script>
</head>
<body>
  <style>
body, html {
  padding: 0;
  margin: 0;
  width: 100%;
  height: 100%;
}
  #map-test {
    width: 100%;
    height: 95%;
    background-color: #333;
  }
  </style>
  <style>
#menu {
            position: absolute;
            width: 12em;
            background: white;
            border: 1px solid #ccc;
            border-radius: 12px;
            padding-bottom: 10px;
            z-index: 2
        }
        #menu ul {
            list-style-type: none;
            padding: 20px;
            margin: 0;
        }
        input {
            width: 10em;
        }

        .header {
            padding: 5px;

        }
.container {
  display: block;
  position: relative;
  padding-left: 35px;
  margin-bottom: 12px;
  cursor: pointer;
  font-size: 15px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

/* Hide the browser's default radio button */
.container input {
  position: absolute;
  opacity: 0;
  cursor: pointer;
}

/* Create a custom radio button */
.checkmark {
  position: absolute;
  top: 0;
  left: 0;
  height: 20px;
  width: 20px;
  background-color: #eee;
  border-radius: 50%;
}

/* On mouse-over, add a grey background color */
.container:hover input ~ .checkmark {
  background-color: #ccc;
}

/* When the radio button is checked, add a blue background */
.container input:checked ~ .checkmark {
  background-color: #2196F3;
}

/* Create the indicator (the dot/circle - hidden when not checked) */
.checkmark:after {
  content: "";
  position: absolute;
  display: none;
}

/* Show the indicator (dot/circle) when checked */
.container input:checked ~ .checkmark:after {
  display: block;
}

/* Style the indicator (dot/circle) */
.container .checkmark:after {
 	top: 9px;
	left: 9px;
	width: 8px;
	height: 8px;
	border-radius: 50%;
	background: white;
}




.send_location_type {
  width:100%;
  text-align: center;
  background: #FF4742;
  border: 1px solid #FF4742;
  border-radius: 6px;
  box-shadow: rgba(0, 0, 0, 0.1) 1px 2px 4px;
  box-sizing: border-box;
  color: #FFFFFF;
  cursor: pointer;
  display: inline-block;
  font-family: nunito,roboto,proxima-nova,"proxima nova",sans-serif;
  font-size: 16px;
  font-weight: 800;
  line-height: 16px;
  min-height: 40px;
  outline: 0;
  padding: 12px 14px;
  text-align: center;
  text-rendering: geometricprecision;
  text-transform: none;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  vertical-align: middle;
}

.send_location_type:hover,
.send_location_type:active {
  background-color: initial;
  background-position: 0 0;
  color: #FF4742;
}
.send_location_type:active {
  opacity: .5;
}
a:hover {
    cursor: default;
    text-decoration: none;
    color:#000000;
}
</style>
  <div id="map-test" class="map"></div>
  <script src="https://api-maps.yandex.ru/2.1/?apikey=81c87445-f1fe-4e16-8b33-c83baf78e8f2&lang=ru_RU"></script>
  <script>
    let center = [42.899657, 71.392727];
    function init()
    {
      let map = new ymaps.Map('map-test',{
        center: center,
        zoom: 16
        });
      var searchControl = new ymaps.control.SearchControl({
        options: {
          provider: 'yandex#search'
                 }
        });

      objectManager = new ymaps.ObjectManager({
                                              geoObjectOpenBalloonOnClick: true
                                              });
      map.geoObjects.add(objectManager);
      
      function get_history_point(type_of_points)
      {
        let point_xhttp = new XMLHttpRequest();
        let csrftoken = "{{ csrf_token }}"
        point_xhttp.open("POST", "{% url 'history_points' %}")
        point_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
        var fire_data = new FormData();
        fire_data.append('type_of_points', type_of_points)
        point_xhttp.send(fire_data)
        point_xhttp.onreadystatechange = function()
          {
            if (this.readyState == 4 && this.status == 200)
            {
              let text_test = this.responseText
              objectManager.add(text_test);
              console.log(type_of_points)
            }
          }
        }
      get_history_point('all')

      
      searchControl.events.add('resultselect', function (e) {
        var results = searchControl.getResultsArray(),
        selected = e.get('index'),
        point = results[selected].geometry.getCoordinates();
        console.log(point)
      })
      //полигон
      //полигон СПЧ-1

      function draw_poligon_1(){
        let polygon_1_xhttp = new XMLHttpRequest();
        let csrftoken = "{{ csrf_token }}"
        polygon_1_xhttp.open("GET", "{% url 'get_polygon_1_points' %}")
        polygon_1_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
        var polygon_1_data = new FormData();
        polygon_1_data.append('get_polygon_1_points', 'True')
        polygon_1_xhttp.send(polygon_1_data)
        polygon_1_xhttp.onreadystatechange = function()
          {
            if (this.readyState == 4 && this.status == 200)
              {
                response_text = this.responseText
                var response_obj = JSON.parse(response_text);
                var response_obj_keys = Object.keys(response_obj)
                var coordinates_to_polygon = []
                for (let key of response_obj_keys)
                  {
                    console.log(response_obj[key]['latitude'], response_obj[key]['longitude'])
                    let one_point = [response_obj[key]['latitude'], response_obj[key]['longitude']]
                    coordinates_to_polygon.unshift(one_point)
                  }
                  console.log(coordinates_to_polygon)
                  console.log(typeof coordinates_to_polygon)

                  const polygon_1 = new ymaps.Polygon([coordinates_to_polygon], {}, {
                    // Курсор в режиме добавления новых вершин.
                    editorDrawingCursor: "crosshair",
                    // Максимально допустимое количество вершин.
                    editorMaxPoints: 10000,
                    // Цвет заливки.
                    fillColor: '#00FF00',
                    opacity: 0.5,
                    // Цвет обводки.
                    strokeColor: '#0000FF',
                    // Ширина обводки.
                    strokeWidth: 1
                  });
                  map.geoObjects.add(polygon_1);
                  $('#edit_poligon_1').click(function () {
                    polygon_1.editor.startEditing();
                  });

                  $('#draw_poligon_1').click(function () {
                    const polygon_1 = new ymaps.Polygon([], {}, {
                      // Курсор в режиме добавления новых вершин.
                      editorDrawingCursor: "crosshair",
                      // Максимально допустимое количество вершин.
                      editorMaxPoints: 10000,
                      // Цвет заливки.
                      fillColor: '#00FF00',
                      opacity: 0.5,
                      // Цвет обводки.
                      strokeColor: '#0000FF',
                      // Ширина обводки.
                      strokeWidth: 1
                      });
                    var stateMonitor = new ymaps.Monitor(polygon_1.editor.state);
                    stateMonitor.add("drawing", function (newValue) {
                      polygon_1.options.set("strokeColor", newValue ? '#FF756B' : '#0000FF');
                    });
                    map.geoObjects.add(polygon_1);
                    polygon_1.editor.startDrawing();
                    $('#save_poligon_1').click(function () {
                      polygon_1.editor.stopDrawing();
                      polygon_1.editor.stopEditing();
                      polygon_1_coordinates = polygon_1.geometry.getCoordinates()[0]
                      var polygon_1_data = new FormData();
                      polygon_1_data.append('update_polygon_1_points', 'True')
                      let id_ = 1
                      for (let element of polygon_1_coordinates)
                        {
                          polygon_1_data.append(id_, element)
                          console.log(element);
                          id_ += 1;
                        }
                      let polygon_1_xhttp = new XMLHttpRequest();
                      let csrftoken = "{{ csrf_token }}"
                      polygon_1_xhttp.open("POST", "{% url 'get_polygon_1_points' %}")
                      polygon_1_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                      polygon_1_xhttp.send(polygon_1_data)
                    });
                  });

                  $('#save_poligon_1').click(function () {
                    polygon_1.editor.stopDrawing();
                    polygon_1.editor.stopEditing();
                    polygon_1_coordinates = polygon_1.geometry.getCoordinates()[0]
                    var polygon_1_data = new FormData();
                    polygon_1_data.append('update_polygon_1_points', 'True')
                    let id_ = 1
                    for (let element of polygon_1_coordinates)
                      {
                        polygon_1_data.append(id_, element)
                        console.log(element);
                        id_ += 1;
                      }
                    let polygon_1_xhttp = new XMLHttpRequest();
                    let csrftoken = "{{ csrf_token }}"
                    polygon_1_xhttp.open("POST", "{% url 'get_polygon_1_points' %}")
                    polygon_1_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                    polygon_1_xhttp.send(polygon_1_data)
                  });

              }
          }

      }
      draw_poligon_1()
      //Полигон СПЧ-2
      function draw_poligon_2(){
        let polygon_2_xhttp = new XMLHttpRequest();
        let csrftoken = "{{ csrf_token }}"
        polygon_2_xhttp.open("GET", "{% url 'get_polygon_2_points' %}")
        polygon_2_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
        var polygon_2_data = new FormData();
        polygon_2_data.append('get_polygon_2_points', 'True')
        polygon_2_xhttp.send(polygon_2_data)
        polygon_2_xhttp.onreadystatechange = function()
          {
            if (this.readyState == 4 && this.status == 200)
              {
                response_text = this.responseText
                var response_obj = JSON.parse(response_text);
                var response_obj_keys = Object.keys(response_obj)
                var coordinates_to_polygon = []
                for (let key of response_obj_keys)
                  {
                    console.log(response_obj[key]['latitude'], response_obj[key]['longitude'])
                    let one_point = [response_obj[key]['latitude'], response_obj[key]['longitude']]
                    coordinates_to_polygon.unshift(one_point)
                  }
                  console.log(coordinates_to_polygon)
                  console.log(typeof coordinates_to_polygon)

                  const polygon_2 = new ymaps.Polygon([coordinates_to_polygon], {}, {
                    // Курсор в режиме добавления новых вершин.
                    editorDrawingCursor: "crosshair",
                    // Максимально допустимое количество вершин.
                    editorMaxPoints: 10000,
                    // Цвет заливки.
                    fillColor: '#0059AC',
                    opacity: 0.5,
                    // Цвет обводки.
                    strokeColor: '#0000FF',
                    // Ширина обводки.
                    strokeWidth: 1
                  });
                  map.geoObjects.add(polygon_2);
                  $('#edit_poligon_2').click(function () {
                    polygon_2.editor.startEditing();
                  });

                  $('#draw_poligon_2').click(function () {
                    const polygon_2 = new ymaps.Polygon([], {}, {
                      // Курсор в режиме добавления новых вершин.
                      editorDrawingCursor: "crosshair",
                      // Максимально допустимое количество вершин.
                      editorMaxPoints: 10000,
                      // Цвет заливки.
                      fillColor: '#0059AC',
                      opacity: 0.5,
                      // Цвет обводки.
                      strokeColor: '#0000FF',
                      // Ширина обводки.
                      strokeWidth: 1
                      });
                    var stateMonitor = new ymaps.Monitor(polygon_2.editor.state);
                    stateMonitor.add("drawing", function (newValue) {
                      polygon_2.options.set("strokeColor", newValue ? '#0059AC' : '#0000FF');
                    });
                    map.geoObjects.add(polygon_2);
                    polygon_2.editor.startDrawing();
                    $('#save_poligon_2').click(function () {
                      polygon_2.editor.stopDrawing();
                      polygon_2.editor.stopEditing();
                      polygon_2_coordinates = polygon_2.geometry.getCoordinates()[0]
                      var polygon_2_data = new FormData();
                      polygon_2_data.append('update_polygon_2_points', 'True')
                      let id_ = 1
                      for (let element of polygon_2_coordinates)
                        {
                          polygon_2_data.append(id_, element)
                          console.log(element);
                          id_ += 1;
                        }
                      let polygon_2_xhttp = new XMLHttpRequest();
                      let csrftoken = "{{ csrf_token }}"
                      polygon_2_xhttp.open("POST", "{% url 'get_polygon_2_points' %}")
                      polygon_2_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                      polygon_2_xhttp.send(polygon_2_data)
                    });
                  });

                  $('#save_poligon_2').click(function () {
                    polygon_2.editor.stopDrawing();
                    polygon_2.editor.stopEditing();
                    polygon_2_coordinates = polygon_2.geometry.getCoordinates()[0]
                    var polygon_2_data = new FormData();
                    polygon_2_data.append('update_polygon_2_points', 'True')
                    let id_ = 1
                    for (let element of polygon_2_coordinates)
                      {
                        polygon_2_data.append(id_, element)
                        console.log(element);
                        id_ += 1;
                      }
                    let polygon_2_xhttp = new XMLHttpRequest();
                    let csrftoken = "{{ csrf_token }}"
                    polygon_2_xhttp.open("POST", "{% url 'get_polygon_2_points' %}")
                    polygon_2_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                    polygon_2_xhttp.send(polygon_2_data)
                  });

              }
          }

      }

      draw_poligon_2()
      //Полигон СПЧ-3
      function draw_poligon_3(){
        let polygon_3_xhttp = new XMLHttpRequest();
        let csrftoken = "{{ csrf_token }}"
        polygon_3_xhttp.open("GET", "{% url 'get_polygon_3_points' %}")
        polygon_3_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
        var polygon_3_data = new FormData();
        polygon_3_data.append('get_polygon_3_points', 'True')
        polygon_3_xhttp.send(polygon_3_data)
        polygon_3_xhttp.onreadystatechange = function()
          {
            if (this.readyState == 4 && this.status == 200)
              {
                response_text = this.responseText
                var response_obj = JSON.parse(response_text);
                var response_obj_keys = Object.keys(response_obj)
                var coordinates_to_polygon = []
                for (let key of response_obj_keys)
                  {
                    console.log(response_obj[key]['latitude'], response_obj[key]['longitude'])
                    let one_point = [response_obj[key]['latitude'], response_obj[key]['longitude']]
                    coordinates_to_polygon.unshift(one_point)
                  }
                  console.log(coordinates_to_polygon)
                  console.log(typeof coordinates_to_polygon)

                  const polygon_3 = new ymaps.Polygon([coordinates_to_polygon], {}, {
                    // Курсор в режиме добавления новых вершин.
                    editorDrawingCursor: "crosshair",
                    // Максимально допустимое количество вершин.
                    editorMaxPoints: 10000,
                    // Цвет заливки.
                    fillColor: '#882652',
                    opacity: 0.5,
                    // Цвет обводки.
                    strokeColor: '#0000FF',
                    // Ширина обводки.
                    strokeWidth: 1
                  });
                  map.geoObjects.add(polygon_3);
                  $('#edit_poligon_3').click(function () {
                    polygon_3.editor.startEditing();
                  });

                  $('#draw_poligon_3').click(function () {
                    const polygon_3 = new ymaps.Polygon([], {}, {
                      // Курсор в режиме добавления новых вершин.
                      editorDrawingCursor: "crosshair",
                      // Максимально допустимое количество вершин.
                      editorMaxPoints: 10000,
                      // Цвет заливки.
                      fillColor: '#882652',
                      opacity: 0.5,
                      // Цвет обводки.
                      strokeColor: '#0000FF',
                      // Ширина обводки.
                      strokeWidth: 1
                      });
                    var stateMonitor = new ymaps.Monitor(polygon_3.editor.state);
                    stateMonitor.add("drawing", function (newValue) {
                      polygon_3.options.set("strokeColor", newValue ? '#882652' : '#0000FF');
                    });
                    map.geoObjects.add(polygon_3);
                    polygon_3.editor.startDrawing();
                    $('#save_poligon_3').click(function () {
                      polygon_3.editor.stopDrawing();
                      polygon_3.editor.stopEditing();
                      polygon_3_coordinates = polygon_3.geometry.getCoordinates()[0]
                      var polygon_3_data = new FormData();
                      polygon_3_data.append('update_polygon_3_points', 'True')
                      let id_ = 1
                      for (let element of polygon_3_coordinates)
                        {
                          polygon_3_data.append(id_, element)
                          console.log(element);
                          id_ += 1;
                        }
                      let polygon_3_xhttp = new XMLHttpRequest();
                      let csrftoken = "{{ csrf_token }}"
                      polygon_3_xhttp.open("POST", "{% url 'get_polygon_3_points' %}")
                      polygon_3_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                      polygon_3_xhttp.send(polygon_3_data)
                    });
                  });

                  $('#save_poligon_3').click(function () {
                    polygon_3.editor.stopDrawing();
                    polygon_3.editor.stopEditing();
                    polygon_3_coordinates = polygon_3.geometry.getCoordinates()[0]
                    var polygon_3_data = new FormData();
                    polygon_3_data.append('update_polygon_3_points', 'True')
                    let id_ = 1
                    for (let element of polygon_3_coordinates)
                      {
                        polygon_3_data.append(id_, element)
                        console.log(element);
                        id_ += 1;
                      }
                    let polygon_3_xhttp = new XMLHttpRequest();
                    let csrftoken = "{{ csrf_token }}"
                    polygon_3_xhttp.open("POST", "{% url 'get_polygon_3_points' %}")
                    polygon_3_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                    polygon_3_xhttp.send(polygon_3_data)
                  });

              }
          }

      }
      draw_poligon_3()

      //Полигон СПЧ-4
      function draw_poligon_4(){
        let polygon_4_xhttp = new XMLHttpRequest();
        let csrftoken = "{{ csrf_token }}"
        polygon_4_xhttp.open("GET", "{% url 'get_polygon_4_points' %}")
        polygon_4_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
        var polygon_4_data = new FormData();
        polygon_4_data.append('get_polygon_4_points', 'True')
        polygon_4_xhttp.send(polygon_4_data)
        polygon_4_xhttp.onreadystatechange = function()
          {
            if (this.readyState == 4 && this.status == 200)
              {
                response_text = this.responseText
                var response_obj = JSON.parse(response_text);
                var response_obj_keys = Object.keys(response_obj)
                var coordinates_to_polygon = []
                for (let key of response_obj_keys)
                  {
                    console.log(response_obj[key]['latitude'], response_obj[key]['longitude'])
                    let one_point = [response_obj[key]['latitude'], response_obj[key]['longitude']]
                    coordinates_to_polygon.unshift(one_point)
                  }
                  console.log(coordinates_to_polygon)
                  console.log(typeof coordinates_to_polygon)

                  const polygon_4 = new ymaps.Polygon([coordinates_to_polygon], {}, {
                    // Курсор в режиме добавления новых вершин.
                    editorDrawingCursor: "crosshair",
                    // Максимально допустимое количество вершин.
                    editorMaxPoints: 10000,
                    // Цвет заливки.
                    fillColor: '#FFE019',
                    opacity: 0.5,
                    // Цвет обводки.
                    strokeColor: '#0000FF',
                    // Ширина обводки.
                    strokeWidth: 1
                  });
                  map.geoObjects.add(polygon_4);
                  $('#edit_poligon_4').click(function () {
                    polygon_4.editor.startEditing();
                  });

                  $('#draw_poligon_4').click(function () {
                    const polygon_4 = new ymaps.Polygon([], {}, {
                      // Курсор в режиме добавления новых вершин.
                      editorDrawingCursor: "crosshair",
                      // Максимально допустимое количество вершин.
                      editorMaxPoints: 10000,
                      // Цвет заливки.
                      fillColor: '#FFE019',
                      opacity: 0.5,
                      // Цвет обводки.
                      strokeColor: '#0000FF',
                      // Ширина обводки.
                      strokeWidth: 1
                      });
                    var stateMonitor = new ymaps.Monitor(polygon_4.editor.state);
                    stateMonitor.add("drawing", function (newValue) {
                      polygon_4.options.set("strokeColor", newValue ? '#FFE019' : '#0000FF');
                    });
                    map.geoObjects.add(polygon_4);
                    polygon_4.editor.startDrawing();
                    $('#save_poligon_4').click(function () {
                      polygon_4.editor.stopDrawing();
                      polygon_4.editor.stopEditing();
                      polygon_4_coordinates = polygon_4.geometry.getCoordinates()[0]
                      var polygon_4_data = new FormData();
                      polygon_4_data.append('update_polygon_4_points', 'True')
                      let id_ = 1
                      for (let element of polygon_4_coordinates)
                        {
                          polygon_4_data.append(id_, element)
                          console.log(element);
                          id_ += 1;
                        }
                      let polygon_4_xhttp = new XMLHttpRequest();
                      let csrftoken = "{{ csrf_token }}"
                      polygon_4_xhttp.open("POST", "{% url 'get_polygon_4_points' %}")
                      polygon_4_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                      polygon_4_xhttp.send(polygon_4_data)
                    });
                  });

                  $('#save_poligon_4').click(function () {
                    polygon_4.editor.stopDrawing();
                    polygon_4.editor.stopEditing();
                    polygon_4_coordinates = polygon_4.geometry.getCoordinates()[0]
                    var polygon_4_data = new FormData();
                    polygon_4_data.append('update_polygon_4_points', 'True')
                    let id_ = 1
                    for (let element of polygon_4_coordinates)
                      {
                        polygon_4_data.append(id_, element)
                        console.log(element);
                        id_ += 1;
                      }
                    let polygon_4_xhttp = new XMLHttpRequest();
                    let csrftoken = "{{ csrf_token }}"
                    polygon_4_xhttp.open("POST", "{% url 'get_polygon_4_points' %}")
                    polygon_4_xhttp.setRequestHeader("X-CSRFToken", csrftoken);
                    polygon_4_xhttp.send(polygon_4_data)
                  });

              }
          }

      }
      draw_poligon_4()
      //полигон

    

    // Контекстное меню, позволяющее изменить параметры метки.
    // Вызывается при нажатии правой кнопкой мыши на метке.
    map.events.add('contextmenu', function (e) {
     
      let xhttp = new XMLHttpRequest();
      
      
      xhttp.onreadystatechange = function()
        {
          if (this.readyState == 4 && this.status == 200)
          {
            check_response(this.responseText)
          }
        }
      function check_response(data){
        console.log('post')
        console.log(data)
      }
      var coords = e.get('coords');
     // Создаем метку.
      var myPlacemark = new ymaps.Placemark(coords, {}, 
        {
          // Красная иконка, растягивающаяся под содержимое.
          preset: "islands#redStretchyIcon",
          iconLayout: 'default#image',
        });
    
        // Если меню метки уже отображено, то убираем его.
      if ($('#menu').css('display') == 'block') 
        {
          $('#menu').remove();
        } 
     else 
        { 
        
          // HTML-содержимое контекстного меню.
          var menuContent =
              '<div id="menu">\
                  <ul id="menu_list">\
                      <li>Адрес: <br /> <textarea rows="3" cols="20" id="address" type="text" name="hint_text" readonly="readonly"></textarea></li>\
                      <li>Комментарии: <br /> <textarea rows="2" cols="20" id="comments" type="text" name="comments" ></textarea></li>\
                        <li><button class="send_location_type" type="submit" id="send_location_type_fire">Пожар</button></li>\
                        <li><button class="send_location_type" type="submit" id="send_location_type_hydrant">Гидрант</button></li>\
                        <li><button class="send_location_type" type="submit" id="send_location_type_secure">ООЗ</button></li>\
                        <li><button class="send_location_type" type="submit" id="close">закрыть</button></li>\
                  </ul>\
            </div>';

          // Размещаем контекстное меню на странице
          $('body').append(menuContent);

          // Задаем позицию меню.
          $('#menu').css({
              left: e.get('pagePixels')[0],
              top: e.get('pagePixels')[1]
           });
          // Заполняем поля контекстного меню текущими значениями свойств метки.
          coordinates = myPlacemark.geometry.getCoordinates()
          $('#menu input[name="latitude"]').val(coordinates[0]);
          $('#menu input[name="longitude"]').val(coordinates[1]);
          
          var myReverseGeocoder = ymaps.geocode([coordinates[0],coordinates[1]])
          
				  myReverseGeocoder.then(function (res) {
            $('#menu textarea[name="hint_text"]').val(res.geoObjects.get(0).properties.get('text'));
            point_data.append('address', res.geoObjects.get(0).properties.get('text'))
            console.log(res.geoObjects.get(0).properties.get('text'))
				  });
          // При нажатии на кнопку "Сохранить" изменяем свойства метки
          // значениями, введенными в форме контекстного меню.
          $('#send_location_type_fire').click(function () {
            console.log("{% url 'point' %}")
            xhttp.open("POST", "{% url 'point' %}")
            let csrftoken = "{{ csrf_token }}"
            xhttp.setRequestHeader("X-CSRFToken", csrftoken);
            var point_data = new FormData();
            address = document.getElementById('address').value
            user_comments = document.getElementById('comments').value
            point_data.append('point_type', 'fire')
            point_data.append('lat', coordinates[0])
            point_data.append('long', coordinates[1])
            point_data.append('address', address)
            point_data.append('user_comments', user_comments)
            xhttp.send(point_data)
            myPlacemark.properties.set({
              balloonContentHeader: 'Пожар',
              balloonContentBody : '<b>Адрес:</b> ' + address +'<br/>' +  '<b>Примечание: </b>' + user_comments,
              balloonContentFooter: "<b>Дата:</b>",
              hintContent: 'Подробности метки пожар'
              });
            myPlacemark.options.set({
              iconLayout: 'default#image',
              iconImageHref: "{% static 'images/fire.png' %}"});
              map.geoObjects.add(myPlacemark);
              $('#menu').remove();
              });

          $('#send_location_type_hydrant ').click(function (e) {
            console.log("{% url 'point' %}")
            xhttp.open("POST", "{% url 'point' %}")
            let csrftoken = "{{ csrf_token }}"
            xhttp.setRequestHeader("X-CSRFToken", csrftoken);
            var point_data = new FormData();
            address = document.getElementById('address').value
            user_comments = document.getElementById('comments').value
            point_data.append('point_type', 'hydrant')
            point_data.append('lat', coordinates[0])
            point_data.append('long', coordinates[1])
            point_data.append('address', address)
            point_data.append('user_comments', user_comments)
            xhttp.send(point_data)
            myPlacemark.properties.set({
              balloonContentHeader: 'Гидрант',
              balloonContentBody : '<b>Адрес:</b> ' + address +'<br/>' +  '<b>Примечание: </b>' + user_comments,
              balloonContentFooter: "<b>Дата:</b> Только что",
              
              hintContent: 'Подробности метки гидрант'
              });

            myPlacemark.options.set({
              iconLayout: 'default#image',
              iconImageHref: "{% static 'images/hydrant1.png' %}"});
              map.geoObjects.add(myPlacemark);
              $('#menu').remove();
          });


          $('#send_location_type_secure').click(function () {
            xhttp.open("POST", "{% url 'point' %}")
            let csrftoken = "{{ csrf_token }}"
            xhttp.setRequestHeader("X-CSRFToken", csrftoken);
            var point_data = new FormData();
            address = document.getElementById('address').value
            user_comments = document.getElementById('comments').value
            point_data.append('point_type', 'secure_place')
            point_data.append('lat', coordinates[0])
            point_data.append('long', coordinates[1])
            point_data.append('address', address)
            point_data.append('user_comments', user_comments)
            xhttp.send(point_data)
            myPlacemark.properties.set({
              balloonContentHeader: 'Объект повышеной безопсности',
              balloonContentBody : '<b>Адрес:</b>' + address +'<br/>' +  '<b>Примечание: </b>' + user_comments,
              balloonContentFooter: "<b>Дата:</b> Только что",
              hintContent: 'Подробности метки ОПБ'
              });
            myPlacemark.options.set({
              iconLayout: 'default#image',
              iconImageHref: "{% static 'images/home.png' %}"});
              map.geoObjects.add(myPlacemark);
              $('#menu').remove();
          });

          $('#close').click(function () {
            $('#menu').remove();
         });

        } 
  });
    
    
}
ymaps.ready(init);
  </script>
    <table id="poligon_1_buttons">
      <tr>
        <td><button id="draw_poligon_1" type="button">Нарисовать Область СПЧ-1</button></td>
        <td><button id="draw_poligon_2" type="button">Нарисовать Область СПЧ-2</button></td>
        <td><button id="draw_poligon_3" type="button">Нарисовать Область СПЧ-3</button></td>
        <td><button id="draw_poligon_4" type="button">Нарисовать Область СПЧ-4</button></td>
      </tr>
      <tr>
        <td><button id="edit_poligon_1">Изменить Область СПЧ-1</button></td>
        <td><button id="edit_poligon_2">Изменить Область СПЧ-2</button></td>
        <td><button id="edit_poligon_3">Изменить Область СПЧ-3</button></td>
        <td><button id="edit_poligon_4">Изменить Область СПЧ-4</button></td>
      </tr>
      <tr>
        <td><button id="save_poligon_1">Сохранить Область СПЧ-1</button></td>
        <td><button id="save_poligon_2">Сохранить Область СПЧ-2</button></td>
        <td><button id="save_poligon_3">Сохранить Область СПЧ-3</button></td>
        <td><button id="save_poligon_4">Сохранить Область СПЧ-4</button></td>
      </tr>
    </table>
</body>
</html>
